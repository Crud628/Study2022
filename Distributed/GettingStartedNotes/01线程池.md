# 线程池

## 二.  定义

### 1.  池

需要的时候可以快速使用，不用重新收集（人才池、蓄水池）

### 2.  线程池

> 不使用线程池，每个任务都新开一个线程
>
> 缺点：线程数量的增加会创建和销毁带来大量的开销问题

##### ①使用线程池的好处

加快响应速度，合理利用CPU和内存，统一管理资源

##### ②使用场景

批量计算任务，服务器处理请求，Excel解析

如果需要使用5个以上的线程，可以使用线程池来管理



## 二.  创建和停止线程池

### 1.  线程池构造方法的参数

corePoolSize  int  核心线程数

​		线程池在完成初始化后，默认情况下，线程池并没有任何线程，线程池会等待有任务到来时，在创建线程再去执行任务。

maxPoolSize  int  核心线程的基础上，额外增加的线程数的上限

![image-20220614202350297](https://typora-imagebed.oss-cn-beijing.aliyuncs.com/img/image-20220614202350297.png)

#### ①添加线程规则

1.如果线程数小于corePoolSize，创建一个线程来运行新任务

2.如果线程数等于或大于corePoolSize但少于maximumPoolSize，则创建一个新线程

3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程

4.如果队列已经满，并且线程数大于或等于maxPoolSize，则拒绝

workQueue 任务存储队列

![image-20220614202846176](https://typora-imagebed.oss-cn-beijing.aliyuncs.com/img/image-20220614202846176.png)

#### ②是否需要增加线程的判断顺序是

- corePoolSize
- workQueue
- maxPoolSize

#### ③Demo

线程池：核心池大小为5，最大池大小为10，队列为100

因为线程中的请求最多会创建5个，然后任务将被添加到队列中。直到达到100.当队列已满时，将创建新的线程maxPoolSize，最多到10个线程，如果再来任务，就拒绝。



#### ④增减线程的特点

- 通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池
- 线程池希望较少的线程数，并且只有再负载变得很大的时候才增加它
- 通过设置maximumPoolSize为很高的值，可以允许线程池容纳任意数量的并发任务
- 只有队列填满时才创建corePoolSize的线程，如果使用的是无界



#### ⑤KeepAlveTime

如果线程池当前的线程数多余corePoolSize，如果多余的线程空闲时间超过KeepAliveTime，他们就会被终止



#### ⑥ThreadFactory 用来创建线程

默认使用Executors.defaultThreadFacyoty()

创建出来的线程都在同一个线程组

如果自己指定ThreadFactory，纳闷呢就可以改变线程名、线程组、优先级、是否守护线程等



#### ⑦workQueue 工作队列

直接交接：SynchronousQueue  没有缓冲  建议大一点

无界队列：LinkedBlockingQueue  可能造成内存浪费 或者OOM

有界的队列：ArrayBlockingQueue 

#### ⑧守护线程 

##### 作用：

给用户线程提供服务 

##### 在Java中有两类线程：

User Thread(用户线程)、Daemon Thread(守护线程) ，

分类标准是线程是否 会阻止JVM的停止——只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部 继续工作；只有当最后一个非守护线程结束时，所有守护线程才会随着JVM一同结束工作。（非守 护线程等同于用户线程）

 我们知道，Java虚拟机通常会继续执行线程，直到发生以下两种中的任一情况时，Java程序才能运 行结束： 

1.已调用System.exit()方法 

2.所有非守护程序线程的线程都已结束 而一般情况下我们不会调用System.exit()方法，所以大部分的Java程序的结束都是由于所有用户线 程都结束而导致的。

 所以可以认为，任何一个守护线程都是整个JVM中所有用户线程（非守护线程）的管家。Daemon 的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它是一 个很称职的守护者。

#### ⑨守护线程的特性

线程类型默认继承自父线程

守护线程创建的线程为默认是守护线程，同样，用户线程创建的线程默认为用户线程。非守护线程 如果想创建一个守护线程，需要调用Thread.setDaemon来设置它（Thread类用布尔值daemon属性 来表示线程是否是守护线程），并且，该方法必须在start之前调用，否则会抛出 IllegalThreadState Exception 异常。

 被谁启动？ 

通常由JVM启动，而不是由用户去启动。当JVM启动时，通常会有一个非守护线程（通常为执行ma in函数的线程）。 

不影响JVM退出 

当只剩下守护线程时，JVM就会退出，因为如果只剩下守护线程，就没必要继续运行程序了。 守护线程没结束并不会影响JVM的正常停止:假设所有用户线程都结束了，那么就算有5个守护线程 正在运行，JVM也会正常停止： 

守护线程和普通线程的区别 

User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经 全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了，这是因为没有了“被守护 者”，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。

 这就是守护线程的作用：告诉JVM不需要等待它退出,当JVM中所有的线程都是守护线程的时候，JV M就可以正常的退出了。 我们是否需要给线程设置为守护线程？ 我们通常不应把自己的线程设置为守护线程，因为设置为守护线程是很危险的。比如线程正在访问 如文件、数据库的时候，所有用户线程都结束了，那么守护线程会在任何时候甚至在一个操作的中 间发生中断，所以守护线程永远不应该去访问固有资源。 

> 代码案例： 
>
> 定义三个线程类，分别是ThreadA，ThreadB，ThreadC。继承Thread类，重写run()方法，在方法 中循环输出线程名称以及执行次数。其中ThreadA，ThreadB为用户线程，循环输出5次。ThreadC 为守护线程，循环输出20次（次数太少无法观察到效果，可以增加循环次数，例如循环输出50次， 100次等）。

### 2.  线程池该手动创建还是自动创建

#### ①newFixedThreadPoolTest

```java
public class Test {
	public static void main(String[] args) {
		ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4);
		for (int i = 0;i < 1000; i++) {
			newFixedThreadPool.execute(new Task());
		}
	}
}
class Task implements Runnable {
	/**
	 * 睡一秒打印当前线程名字
	 */
	@Override
	public void run() {
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(Thread.currentThread().getName());
	}
}
// out:
// pool-1-thread-1
// pool-1-thread-3
// pool-1-thread-2
// pool-1-thread-1
// pool-1-thread-4
// ....
```

源码

```java
/**
     * Creates a thread pool that reuses a fixed number of threads
     * operating off a shared unbounded queue.  At any point, at most
     * {@code nThreads} threads will be active processing tasks.
     * If additional tasks are submitted when all threads are active,
     * they will wait in the queue until a thread is available.
     * If any thread terminates due to a failure during execution
     * prior to shutdown, a new one will take its place if needed to
     * execute subsequent tasks.  The threads in the pool will exist
     * until it is explicitly {@link ExecutorService#shutdown shutdown}.
     *
     * @param nThreads the number of threads in the pool
     * @return the newly created thread pool
     * @throws IllegalArgumentException if {@code nThreads <= 0}
     */
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
    /**         {@code corePoolSize < 0}<br>
     *         {@code keepAliveTime < 0}<br>
     *         {@code maximumPoolSize <= 0}<br>
     * /        {@code maximumPoolSize < corePoolSize}
```

固定数量线程池，容易造成大量内存占用，可能OOM

#### ②newSingleThreadExecutor

只有一个线程

```java
    /**
     * Creates an Executor that uses a single worker thread operating
     * off an unbounded queue. (Note however that if this single
     * thread terminates due to a failure during execution prior to
     * shutdown, a new one will take its place if needed to execute
     * subsequent tasks.)  Tasks are guaranteed to execute
     * sequentially, and no more than one task will be active at any
     * given time. Unlike the otherwise equivalent
     * {@code newFixedThreadPool(1)} the returned executor is
     * guaranteed not to be reconfigurable to use additional threads.
     *
     * @return the newly created single-threaded Executor
     */
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```

#### ③newCacheThreadPool

无界线程池，可以回收多余线程 直接交换

弊端：核心数量为0，最大数量为MAX_INT

![image-20220614210625782](https://typora-imagebed.oss-cn-beijing.aliyuncs.com/img/image-20220614210625782.png)

#### ④ScheduledThreadPool

可以做和时间相关的，计划的

```java
/**
     * A wrapper class that exposes only the ScheduledExecutorService
     * methods of a ScheduledExecutorService implementation.
     */
private static class DelegatedScheduledExecutorService
    extends DelegatedExecutorService
    implements ScheduledExecutorService {
    private final ScheduledExecutorService e;
    DelegatedScheduledExecutorService(ScheduledExecutorService executor) {
        super(executor);
        e = executor;
    }
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        return e.schedule(command, delay, unit);
    }
    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
        return e.schedule(callable, delay, unit);
    }
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        return e.scheduleAtFixedRate(command, initialDelay, period, unit);
    }
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return e.scheduleWithFixedDelay(command, initialDelay, delay, unit);
    }
}
```

### 3.  正确的创建线程池方法

根据不同业务场景，设置参数

##### ①  线程池的线程数量设定为多少比较合适

CPU密集型（加密、计算）：最佳线程数为CPU核心的1-2倍

耗时IO型（读写数据库、文件、网络读写等）：最佳线程数会大于线程数很多倍

![image-20220614211524738](https://typora-imagebed.oss-cn-beijing.aliyuncs.com/img/image-20220614211524738.png)

##### ②  对比

![image-20220614213811308](https://typora-imagebed.oss-cn-beijing.aliyuncs.com/img/image-20220614213811308.png)

##### ③  workStealingPool（Since 1.8）

子任务、窃取、不保证执行顺序



### 4.  停止线程池

shutdown  关闭线程池，并不一定能会停止，新任务不会增加，现存任务执行完毕
